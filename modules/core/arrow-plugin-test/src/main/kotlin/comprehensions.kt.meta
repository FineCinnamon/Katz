package arrow.extreme

//metadebug

import kotlin.reflect.KProperty

class IO<A>(val value: A) {

  operator fun getValue(value: Any?, property: KProperty<*>): A = TODO()

  fun <B> flatMap(f: (A) -> IO<B>): IO<B> =
    f(value)

  companion object {
    fun <A> fx(f: IO.Companion.() -> A): IO<A> = TODO()
    fun <A> just(a: A): IO<A> = IO(a)
  }
}

fun   test1 ()  : IO<Int> =
  IO(1).flatMap { a : Int -> 
IO(1).flatMap { b : Int -> 
IO.just(a + b)
}
}

fun   test2 ()  =
  IO(1).flatMap { a  -> 
IO(1).flatMap { b  -> 
IO.just(a + b)
}
}

fun   test3 ()  =
  IO.fx {
      val a by IO(1)
      val b by IO(1)
      a + b
    }.flatMap { a  -> 
IO.fx {
      val a by IO(1)
      val b by IO(1)
      a + b
    }.flatMap { b  -> 
IO.just(a + b)
}
}

fun   test4 ()  : IO<Int> =
  IO(1).flatMap { a  -> 
val t = a + 1
IO(1).flatMap { b  -> 
val y = a + b
IO(1).flatMap { f  -> 
val n = a + 1
IO(1).flatMap { g  -> 
IO.just(y + f + g + t + n)
}
}
}
}

fun test5(): IO<Int> = //simple TODO Should this fail at compile time due to lack of bindings to enforce efficiency recommending just or just lift the pure value?
  IO.fx { 1 + 1 }
