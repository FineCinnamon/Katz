package arrow.generic.coproduct2

import arrow.core.Option
import arrow.core.toOption
import kotlin.Suppress
import kotlin.Unit

/**
 * Represents a sealed hierarchy of 2 types where only one of the types is actually present.
 */
sealed class Coproduct2<out A, out B>

/**
 * Represents the first type of a Coproduct2
 */
data class First<A, B>(val a: A) : Coproduct2<A, B>()

/**
 * Represents the second type of a Coproduct2
 */
data class Second<A, B>(val b: B) : Coproduct2<A, B>()

/**
 * Creates a Coproduct from the A type
 *
 * @return A Coproduct2<A, B> where the receiver is the A
 */
fun <A, B> A.first(): Coproduct2<A, B> = First(this)

/**
 * Creates a Coproduct from the B type
 *
 * @return A Coproduct2<A, B> where the receiver is the B
 */
fun <A, B> B.second(): Coproduct2<A, B> = Second(this)

/**
 * Transforms the Coproduct into an Option based on the actual value of the Coproduct
 *
 * @return None if the Coproduct was not the specified type, Some if it was the specified type
 */
fun <A> Coproduct2<A, *>.select(): Option<A> = (this as? First)?.a.toOption()

/**
 * Transforms the Coproduct into an Option based on the actual value of the Coproduct
 *
 * @return None if the Coproduct was not the specified type, Some if it was the specified type
 */
@Suppress("UNUSED_PARAMETER")
fun <B> Coproduct2<*, B>.select(dummy0: Unit = Unit): Option<B> = (this as? Second)?.b.toOption()

/**
 * Runs the function related to the actual value of the Coproduct and returns the result
 *
 * @param a The function used to map A to the RESULT type
 * @param b The function used to map B to the RESULT type
 *
 * @return RESULT generated by one of the input functions
 */
fun <A, B, RESULT> Coproduct2<A, B>.fold(a: (A) -> RESULT, b: (B) -> RESULT): RESULT = when (this) {
    is First -> a(this.a)
    is Second -> b(this.b)
}
